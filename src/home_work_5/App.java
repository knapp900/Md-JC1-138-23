package home_work_5;

import home_work_5.DTO.Animal;
import home_work_5.DTO.Person;

import java.util.*;

/*
Коллекции, полиморфизм, DTO, Supplier*, Comparator:
1.Создаём классы только для хранения информации об объектах (DTO):
	1.1. Написать класс Person который содержит поля:
		1.1.1. Строку nick - псевдоним пользователя
		1.1.2. Строку password - пароль (от 5 до 10 символов)
		1.1.3. Строку name - имя пользователя
	1.2. Написать класс Animal:
		1.2.1. Число age - возраст (от 1 до 15 лет)
		1.2.2. Строка nick - кличка
2. Для имён:
	2.1 Генерировать рандомную строку (не важно из чего состоит)
	2.2 Генерировать рандомную строку (состоящую из русских букв)
	2.3 Генерировать рандомное имя (настоящее имя)
	2.4* Генерировать рандомное имя (имена получать из файла)
3. Для клички:
	3.1 Генерировать рандомную строку (не важно из чего состоит)
	3.2 Генерировать рандомную строку (состоящую из русских букв)
	3.3 Генерировать рандомное имя (настоящие клички животных)
	3.4* Генерировать рандомное имя (клички получать из файла)
4. Для псевдонимов:
	4.1 Генерировать рандомную строку (не важно из чего состоит)
	4.2 Генерировать рандомную строку (состоящую из анлийских букв)
	4.3* Генерировать рандомное имя (псевдонимы получать из файла)
5. Создать компараторы (Comparator) для классов которые сравнивают:
	5.1. Длину пароля пользователей
	5.2. Длину пароля пользователей и псевдонимы пользователей по алфавиту (Смотрите уточнение в пункте 5.99)
	5.3. Возраст животных
	5.4. Возраст животных и клички животных по алфавиту (Смотрите уточнение в пункте 5.99)
	5.99. Особенность данных компораторов в том что у вас при сортировке должна получиться группировка, сначала по первому полю, потом по второму. Пример для класса Animal
		К примеру: есть список животных [{age: 10, nick: "Анатолий"}, {age: 10, nick: "Игнат"}, {age: 1, nick: "Люцифер"}, {age: 10, nick: "Ярик"}].
		После сортировки должно получиться: [{{age: 1, nick: "Люцифер"}, {age: 10, nick: "Анатолий"}, {age: 10, nick: "Игнат"}, {age: 10, nick: "Ярик"}].
		Так как сначала сортируется по возрасту в порядке возрастания, а потом в рамках группу (пример: age = 10), сортируется по кличке по возрастанию (по алфавиту).
6. Работа с коллекциями. Выполняем действия над экземплярами классов созданных на основания задания 1:
	6.0* В идеале можно, используя полиморфизм, написать метод который будет выполнять основную работу над коллекциями наполненными любыми данными + методы для каждого из
	     класса из пункта 1. Например метод который генерирует Person и заполняет ими указанную вами коллекцию указанным количеством  Person. Получившуюся коллекцию передаём
	     во второй метод который выполняет все остальные прописанные действия.
	6.1. При помощи рандома генерируем 1_000_000 (Если компьютер глючит сделать 100_000) разных объектов одного класса. Поля заполняются рандомными данными.
	6.2. Заполняем:
		6.2.1. LinkedList
		6.2.2. ArrayList
		6.2.3. HashSet
		6.2.4. TreeSet
	6.3. Отсортировать коллекции используя компараторы созданные в этом ДЗ.
		6.3.1. Сортируем встроенными средствами jdk
		6.3.2.* Сортируем собственным методом сортировки
	6.4. Замерить время и распечатать в консоль скорость каждой перечисленной операции: "Операция: ХХХХ. Заняла YYYY мс". Для замера использовать метод из jdk System.currentTimeMillis():
		6.4.1. Заполнения коллекции
		6.4.2. Итерирования коллекции:
			6.4.2.1. При помощи iterator
			6.4.2.2. При помощи любого другого способа (не foreach)
		6.4.3. Удаления всех элементов коллекции (выбрать один из):
			6.4.3.1. При помощи iterator
			6.4.3.2. При помощи любого другого способа
 */

public class App {

    public static void main(String[] args) {

        Operations operations = new OperationWithCollectionsImpl();

        Animal animal = new Animal();

        List<Animal> linkedAnimals = new LinkedList<>();
        operations.doOperations(animal,linkedAnimals,1_000_000);
        List<Animal> arrayAnimals = new ArrayList<>();
        operations.doOperations(animal,arrayAnimals,1_000_000);
        Set<Animal> hashSetAnimals = new HashSet<>();
        operations.doOperations(animal,hashSetAnimals,1_000_000);
        Set<Animal> treeSetAnimals = new TreeSet<>();
        operations.doOperations(animal,treeSetAnimals,1_000_000);


        Person person = new Person();

        List<Person> linkedPersons = new LinkedList<>();
        operations.doOperations(person,linkedPersons,1_000_000);
        List<Person> arrayPersons = new ArrayList<>();
        operations.doOperations(person,arrayPersons,1_000_000);
        Set<Person> hashSetPersons = new HashSet<>();
        operations.doOperations(person,hashSetPersons,1_000_000);
        Set<Person> treeSetPersons = new TreeSet<>();
        operations.doOperations(person,treeSetPersons,1_000_000);

        /*
        Операция: Заполнение коллекции Animal java.util.LinkedList. Заняла 204 мс
        Операция: Итерирование коллекции (iterator) java.util.LinkedList. Заняла 15 мс
        Операция: Итерирование коллекции (не foreach) java.util.LinkedList. Заняла 21 мс
        Операция: Удаление всех элементов коллекции java.util.LinkedList. Заняла 63 мс
        Операция: Заполнение коллекции Animal java.util.ArrayList. Заняла 89 мс
        Операция: Итерирование коллекции (iterator) java.util.ArrayList. Заняла 8 мс
        Операция: Итерирование коллекции (не foreach) java.util.ArrayList. Заняла 4 мс
        Операция: Удаление всех элементов коллекции java.util.ArrayList. Заняла 75488 мс
        Операция: Заполнение коллекции Animal java.util.HashSet. Заняла 110 мс
        Операция: Итерирование коллекции (iterator) java.util.HashSet. Заняла 0 мс
        Операция: Итерирование коллекции (не foreach) java.util.HashSet. Заняла 0 мс
        Операция: Удаление всех элементов коллекции java.util.HashSet. Заняла 0 мс
        Операция: Заполнение коллекции Animal java.util.TreeSet. Заняла 51 мс
        Операция: Итерирование коллекции (iterator) java.util.TreeSet. Заняла 0 мс
        Операция: Итерирование коллекции (не foreach) java.util.TreeSet. Заняла 0 мс
        Операция: Удаление всех элементов коллекции java.util.TreeSet. Заняла 0 мс
        Операция: Заполнение коллекции Person java.util.LinkedList. Заняла 2083 мс
        Операция: Итерирование коллекции (iterator) java.util.LinkedList. Заняла 49 мс
        Операция: Итерирование коллекции (не foreach) java.util.LinkedList. Заняла 50 мс
        Операция: Удаление всех элементов коллекции java.util.LinkedList. Заняла 93 мс
        Операция: Заполнение коллекции Person java.util.ArrayList. Заняла 1617 мс
        Операция: Итерирование коллекции (iterator) java.util.ArrayList. Заняла 8 мс
        Операция: Итерирование коллекции (не foreach) java.util.ArrayList. Заняла 1 мс
        Операция: Удаление всех элементов коллекции java.util.ArrayList. Заняла 68702 мс
        Операция: Заполнение коллекции Person java.util.HashSet. Заняла 2092 мс
        Операция: Итерирование коллекции (iterator) java.util.HashSet. Заняла 67 мс
        Операция: Итерирование коллекции (не foreach) java.util.HashSet. Заняла 50 мс
        Операция: Удаление всех элементов коллекции java.util.HashSet. Заняла 223 мс
        Операция: Заполнение коллекции Person java.util.TreeSet. Заняла 2966 мс
        Операция: Итерирование коллекции (iterator) java.util.TreeSet. Заняла 53 мс
        Операция: Итерирование коллекции (не foreach) java.util.TreeSet. Заняла 122 мс
        Операция: Удаление всех элементов коллекции java.util.TreeSet. Заняла 232 мс
         */

    }
}
